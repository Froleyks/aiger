         The AIGER And-Inverter Graph (AIG) Format Version 20060915
         ----------------------------------------------------------
              Armin Biere, Johannes Kepler University, 2006

  This report describes the AIG file format as used by the AIGER library.
  The purpose of this report is not only to motivate and document the
  format, but also to allow independent implementations of writers and
  readers by giving a precise and unambiguous definitions.

Acknowledgements

  The format went through various incarnations even before real code became
  available.  In particular the following colleagues gave invaluable
  feedback on earlier drafts.

      Alessandro Cimatti, Koen Claessen, Niklas Een, Marc Herbstritt,
      Ken McMillan, Fabio Somenzi, Niklas Soerenson, Allen Van Gelder.

  We also want to thank Holger Hermmans who started the discussion on having
  a model checking competition affiliated to CAV and also provided strong
  support after the idea became more concrete.

Introduction

  The name AIGER contains as one part the acronym AIG of And-Inverter
  Graphs and also if pronounced in German sounds like the name of the
  'Eiger', a mountain in the Swiss alps.  This choice should emphasize the
  origin of this format. It was first openly discussed at the Alpine
  Verification Meeting 2006 in Ascona as a way to provide a simple, compact
  file format for a model checking competition affiliated to CAV 2007.

  The AIGER format has an ASCII and a binary version.  The ASCII version is
  the format of choice if an AIG is to be saved by an application which
  does not want to use the AIGER library.  It is simple to generate and has
  less restrictions.  The binary format is more restricted and much more
  compact.  It is easier to read and thus should be the format of choice for
  competitions.  The AIGER library comes with conversion utilities of course.

  Let us start with some simple example in ASCII which all can be found in
  the 'examples' subdirectory.  The empty circuit without inputs nor outputs
  consists of the single line

    p aig 0 0 0 0 0             header
  
  The file that consists of the following two lines

    p aig 0 0 0 1 0             header
    0                           output

  represents the constant FALSE.  Note that the comments to the right are
  not part of the file.  The following file represents the constant TRUE:
    
    p aig 0 0 0 1 0
    1

  The single '1' in the header specifies that the number of outputs is one.
  In this case the header is followed by a line which contains the literal
  of the single output.

  The following file is a buffer

    p aig 1 1 0 1 0             header
    2                           input
    2                           output

  and the following an inverter

    p aig 1 1 0 1 0             header
    2                           input
    3                           output          !1

  The maximal variable index is 1, the first number.  The second number
  represents the number of inputs.  The first line consists of the single
  input literal.  A variable is transformed into a literal by multiplying
  it by two.  In the first case the output specified on the last line leaves
  the input unchanged.  In the second case the output inverts the input.  The
  output literal '3' has its sign bit, the least significant bit, set to one
  accordingly.
  
  An AND gate looks as follows

    p aig 3 2 0 1 1
    2                           1st input
    4                           2nd input
    6                           output
    6 2 4                       AND gate        1 & 2

  The literal representing the AND gate is '6' with variable index '3',
  the first number in the header, which denotes the maximal variable index.
  The last number is the number of AND gates.

  An OR gate can be formulated as

    p aig 3 2 0 1 1
    2                           1st input
    4                           2nd input
    7                           output          !(!1 & !2)
    6 3 5                       AND gate        !1 & !2

  Let us now turn to a more complete combinational circuit

    p aig 7 2 0 2 3             header line
    2                           1st input       1st addend bit 'x'
    4                           2nd input       2nd addend bit 'y'
    6                           1st output      sum bit        's'
    12                          2nd output      carry          'c'
    6 13 15                     1st AND gate    x ^ y
    12 2 4                      2nd AND gate    x & y
    14 3 5                      3rd AND gate    !x & !y
    i0 2 x                      1st symbol
    i1 4 y                      2nd symbol
    o0 6 s                      3rd symbol
    o1 12 c                     4th symbol
    c                           comment header
    half adder                  comment

  The symbol table is optional and does not need to be complete, but may
  only contain symbols for inputs, latches, or outputs.

  Sequential circuits have latches as state elements. Here is a toggle flip
  flop, which has no input, one latch, and two outputs, its current state and
  its negation:

    p aig 1 0 1 2 0
    2 3                         1st latch with next state literal
    2                           1st output
    3                           2nd output

  Latches are always assumed to be initialized to zero.  The same toggle
  flip flop with an enable and additional explicit active low reset input:

    p aig 7 2 1 2 4
    2                           1st input       'enable'
    4                           2nd input       'reset'
    6 8                         1st latch       Q next(Q)
    6                           1st output      Q
    7                           2nd output      !Q
    8 4 10                      1st AND gate    reset & (enable ^ Q)
    10 13 15                    2nd AND gate    enable ^ Q
    12 2 6                      3rd AND gate    enable & Q
    14 3 7                      3rd AND gate    !enable & !Q

  The order of the literals and the definitions of the AND gates
  is irrelevant.  The binary format described more formally below places
  more restrictions on the order and also does not allow unused literals.

Design Choices
  
  The format should allow to model combinational circuits.

  Structural SAT problems can be described.
  
  The format should allow to model sequential circuits.

  Model checking problems can be described.

  The operators are restricted to bit level.

  The set of operators needs to be as simple as possible.

  A compact standardized binary format should be available.

  The ASCII format should be as easy as possible to write by programs.

  The binary format should be as easy as possible to read by programs.

  A Symbol table and comments can be included.

  Symbol table and comments can be ignored reading the file sequentially.

  Some simple form of extensibility should be possible.

Header

  The AIGER format describes circuits by multi-rooted And-Inverter Graphs
  (AIGs) and starts with a header of the following form

    p [ab]ig m i l o a

  The maximal variable index 'm' is the first number in the header.  The
  circuit has 'i' inputs, 'l' latches, 'o' outputs, and consists of 'a' AND
  gates.  If all variables are used and there are no unused AND gates then
  'm = i + l + a'.

  The format identifier string '[ab]ig' is either 'aig' in case of the ASCII
  format or 'big' for the binary format.  It  is followed by 5 non negative
  integers encoded in ASCII format.  An unsigned respectively non negative
  integer is either '0' or a strictly positive ASCII encoded digit followed
  by a sequence of digits.  The header line ends with a new line character
  immediately after the last digit of the number of ands 'a'.  The first
  character 'p' is the first character of the file.  The 'p', the format
  identifier string 'aig' and the numbers are separated by exactly one space
  character ' '.

Variables and Literals

  Literals are constants or signed variables and are also represented by
  unsigned integers.  The least significant bit of the unsigned word
  encoding a literal is the sign bit.  The remaining bits represent the
  variable index.
  
  In essence, to obtain the sign bit of a literal we take its unsigned
  integer representation modulo 2.  A sign bit of one means negated, a sign
  bit of zero unnegated.  To extract the variable from a literal we divide
  it by 2.  To obtain a literal from a variable in the other direction we
  multiple the variable index by 2 and optionally add 1 if the variable
  should be negated.   A literal can be negated by just toggling its least
  significant bit.
  
  The constant FALSE is represented by the literal '0', the constant TRUE by
  '1'.  This implies, that FALSE is unnegated, while TRUE is negated.

  AIGER only models cycle-accurate models.  Latches are are assumed to have
  a reset zero state, e.g. are initialized to zero and no explicit reset nor
  clock signal is necessary.

ASCII Format
  
  The ASCII format has 'aig' as format identifier in the header, which is an
  acronym for ASCII AIG.  The names of files in the ASCII format are
  supposed to have an '.aig'  extension.  The current AIGER library also
  supports files compressed with GNU GZIP.  In this case an additional '.gz'
  suffix is expected.

  After the header the 'i' inputs are listed, one per line, as unnegated
  literal, e.g.  represented as even positive integers.  Then the 'l'
  latches are defined.  Again one latch per line.  Each line consists of
  exactly two positive integers separated by a space character.  The first
  is even and denotes the current state of the latch. The second is the
  literal that defines the next state function of this latch.  
  
  Then the 'o' output literals are listed, one per line.  Here arbitrary
  literals are allowed.  This concludes the interface part and the
  definitions of the 'a' AND gates follow.

  The definition of an AND gate consists of three positive integers all
  written on one line and separated by exactly one space character.  The
  first integer is even and represents the literal or left-hand side (LHS).
  The two other integers represent the literals of the right-hand side
  (RHS) of the AND gate.

  In order to be well formed, the 'i' inputs, the current state literal of
  the 'l' latches, e.g. the pseudo-primary inputs, and the LHS of the 'a'
  AND gates are all different and define exactly 'i + l + a' literals.  The
  other literals, except for the two constants '0' and '1', are undefined
  and can not be used as output, as next state literal, nor on the RHS of an
  AND.  Furthermore, the definitions of the ANDs have to be acyclic.  To be
  more precise: The literal on the LHS of an AND is defined to depend on the
  literals on the RHS after stripping sign bits.  The transitive non
  reflexive closure of this dependency relation has to be acyclic.

  In the ASCII format both checking for undefined literals and checking for
  cyclic dependencies has to be done explicitly.  This is the price one has
  to pay for a simple, easy to generate and less restricted format.  The
  binary format on the other hand has a strict order requirement on the
  literals not only for inputs and latches, but also for the RHS literals
  with respect to the LHS literals. The binary format does not require such
  an explicit check.

  Also note that the number of defined literals does not have to match the
  maximal variable index 'm'.  In essence, some literals may just not be
  used in ASCII format.

Symbols
  
  After the definitions of the AND gates an optional symbol table may
  follow.  A symbol is an arbitrary ASCII string of printable characters
  excluding the new line character.  Symbols can only be attached to inputs,
  latches and outputs and there is at most one symbol per input, latch or
  output allowed.  A symbol entry makes up one line in the input and
  consists of a symbol type specifier which is either 'i', 'l', or 'o' on
  the first character position, followed by a position, which is not
  separated by a space, and then the literal separated by a space.  After
  another space the symbol name starts and continues until but not including
  the next new line character.  Therefore a symbol table entry looks as
  follows:
    
    [ilo] pos lit
  
  The position 'pos' of the symbol denotes the position of the input, latch,
  or AND gate, in the list of inputs, latches, and ANDs respectively.  The
  literal has to be the same as the actual literal given at that position in
  the corresponding list.

  The symbol table is put after all the definitions, such that an
  application reading an AIG can just stop reading the file after it has
  read the definitions.  The same applies to comments which come last.

Comments
 
  After the symbol table an optional comment section may start.  The comment
  section starts with a 'c' character followed by a new line.  The following
  lines are comments.  Each comment starts at the first character of a line
  and extends until the next new line character.  There may no comment lines
  at all, but the last comment has to be terminated by a new line character,
  which then also has to be the last character of the file.

Binary Format Motivation

  The binary format is more restricted than the ASCII format.  Literals have to
  follow a specific order.  The order restrictions and using a
  two-complement binary representation of numbers makes the binary format
  not only easier to read but also much more compact.  Experiments show that
  these restrictions and an additional delta encoding result in smaller
  uncompressed files.  The binary format is often smaller than the same
  model in GZIP compressed ASCII format.  Without symbol tables the
  reduction is typically a factor of two compared to the GZIP compressed
  ASCII format.  Compressing the binary format results in additional
  reduction.  
  
  Consider the following SMV model 'texas.parsesys^1.E.smv', the largest
  benchmark from the TIP suite:  
  
    1204637 texas.parsesys^1.E.smv/unmangled.smv
     485595 texas.parsesys^1.E.smv/mangled.smv
     192282 texas.parsesys^1.E.smv/unstripped.aig
     185100 texas.parsesys^1.E.smv/stripped.aig
     114796 texas.parsesys^1.E.smv/unmangled.smv.gz
      97455 texas.parsesys^1.E.smv/mangled.smv.gz
      73282 texas.parsesys^1.E.smv/unstripped.aig.gz
      70698 texas.parsesys^1.E.smv/stripped.aig.gz
      45281 texas.parsesys^1.E.smv/unstripped.big
      38099 texas.parsesys^1.E.smv/stripped.big
      28989 texas.parsesys^1.E.smv/unstripped.big.gz
      26257 texas.parsesys^1.E.smv/stripped.big.gz

  After flattening and binary encoding, the SMV model has a size of 1204637
  bytes (unmangled.smv).  Simply renaming the symbols, e.g. mangling them,
  results in a reduction in file size of almost a factor of 3.  At least
  another factor of two can be obtained by translating the original
  unmangled SMV file into an AIG and writing it in the ASCII format
  (unstripped.aig).  This file still contains all the unmangled symbols.
  Stripping the symbol table reduces the size slightly (stripped.aig).
  Compressing these four files with GZIP results in another reduction of at
  least 2.  In particular note, that the uncompressed and unstripped binary
  format is two third the size of the compressed and stripped ASCII format.
  Finally using the binary format, gives almost an additional factor of two.
  Compressing the binary format gives further reduction.

  For the whole TIP suite the sizes are as follows

    11300354 tip/unmangled.tar.gz
     7957504 tip/mangled.tar.gz
     2663375 tip/aigtosmv.tar.gz
     2294823 tip/aig.tar.gz
      349036 tip/big.tar.gz

  Here we stripped the symbols in the AIG case.  The tar file
  'aigtosmv.tar.gz' contains the result of translating the files from binary
  format (tip/big.tar.gz) back into SMV format.  It is also remarkable, that
  with the exception of the binary format, GZIP can not make use of the fact
  that most of the models in the TIP suite occur multiple times though with
  different properties.

  These experiments show that using a binary format can considerably reduce
  space requirements to store the benchmarks.  Furthermore it will reduce
  reading these benchmarks.  This reduction is even more important if the
  AIGER format is used for large combinational benchmarks, e.g. in a SAT
  context.
  
Binary Format Definition

  The binary format is semantically a subset of the ASCII format with a
  slightly different syntax.  The binary format may need to reencode
  literals, but translating a file in binary format into ASCII format and
  then back in to binary format will result in the same file.

  The header of a AIGER file in binary format has 'big' as format
  identifier, but otherwise is identical to the ASCII header.  The standard
  file extension for the binary format is therefore 'big' It reminds the
  user that it is supposed to be used for large AIGs.  At the same time it
  is an acronym for binary AIG format.  
  
  An header for the binary format looks as follows:

    p big m i l o a

  Constants, variables and literals are handled in the same way as in the
  ASCII format.  The first simplifying restriction is, that the input
  literals come first, followed by the pseudo-primary inputs of the latches
  and then all LHS literals of AND gates.  These literals form consecutive
  intervals of even positive integers without gaps from '2' to '2 * m'.

      inputs            2,          4,  ... ,  2*i
      latches       2*i+2,      2*i+4,  ... ,  2*(i+l)
      ands      2*(i+l)+2,  2*(i+l)+4,  ... ,  2*(i+l+a)

  All literals have to be defined, and therefore 'm = i + l + a'.  With this
  restriction it becomes possible that the inputs and the current state
  literals of the latches do not have to be explicitly listed.

  After the header the list of 'l' next state literals follows, one per
  latch on a single line.  Then the 'o' outputs are listed, one per line.

  In the binary format we assume that the AND gates are ordered and respect
  the child parent relation.  AND gates with smaller literals on the LHS
  come first.  Therefore we can assume that the literals on the right-hand
  side of a definition of an AND gate are smaller than the LHS literal.
  Furthermore we can sort the literals on the RHS, such that the larger
  literal comes first.  A definition thus consists of three literals
    
      lhs rhs0 rhs1

  with 'lhs' even and 'lhs > rhs0 > rhs1'.  Also the variable indices are
  pairwise different to avoid combinational self loops.  Since the LHS
  indices of the definitions are all consecutive (as even integers),
  the binary format does not have to keep 'lhs'.  In addition, we can use
  the order restriction and only write the differences 'delta0' and 'delta1'
  instead of 'rhs0' and 'rhs1', with

      delta0 = lhs - rhs0,  delta1 = rhs0 - rhs1
  
  The differences will all be strictly positive, and in practice often very
  small.  We can take advantage of this fact by the simple little-endian
  encoding of unsigned integers of the next section.  After the binary delta
  encoding of the RHSs of all AND gates, the optional symbol table and
  optional comment section start with the same format as in the ASCII case.

Binary Encoding of Deltas
  
  Assume that 'wi, ..., w0' are 7-bit words, 'w1' to 'wi' all non zero and
  the unsigned number 'x' can be represented as
    
    x = w0 + 2^7*w1 + 2^14*w2 + 2^(7*i)*wi

  The binary encoding of x in AIGER is the sequence of i bytes b0, ... bi:

    0w0, 0w1, 0w2, ..., 1wi

  The MSB of a byte in this sequence signals whether this byte is the last
  byte in the sequence, or whether there are still more bytes to expect.
  Here are some examples:
    
      unsigned integer   byte sequence of encoding (in hexadecimal)
 
                     x   b0 b1 b2 b3
                        
                     0   00
                     1   01
      2^7-1    =   127   7f
      2^7      =   128   00 01
      2^8  + 2 =   258   02 02
      2^14 - 1 = 16383   ff 7f
      2^14 + 3 = 16387   03 00 01
      2^28 - 1           ff ff ff 7f
      2^28 + 7           07 00 00 00 01

  This encoding can reduce the number of bytes by at most a factor of 4,
  which in practice often is almost reached, in particular in our
  application where many small numbers are expected.
  
  This binary encoding of arbitrary precision unsigned integers is
  platform-independent and thus 64-bit clean.  Unfortunately, this is not
  true for the following code snippets in C.  We also just ignore overflows
  and file errors, but otherwise this code shows that encoding and decoding
  is very simple.

    unsigned
    decode (FILE * file)
    {
      unsigned x = 0, i = 0;
      unsigned char ch;

      while ((ch = getc (file)) & 0x80)
        x |= (ch & 0x7f) << (7 * i++);

      return x | (ch << (7 * i));
    }

    void
    encode (FILE * file, unsigned x)
    {
      unsigned char ch;

      while (x & ~0x7f)
        {
          ch = (x & 0x7f) | 0x80;
          putc (ch, file);
          x >>= 7;
        }
     
      ch = x;
      putc (ch, file);
    }

  Note that the decoder above is not robust at all, since an early EOF may
  actually result in an infinite loop.  In the binary format of AIGER we
  always expect a complete sequence.  Therefore if an EOF is read before
  the sequence is complete a parser error occurs.  A simple solution to this
  problem is to replace to check the return value of 'getc'.  If the value
  is EOF then abort decoding with a parse error.

Property Checking
  
  The AIGER format can easily be used for various types of property
  checking.  A combinational circuits with no latches, e.g. l = 0, and
  exactly one output can be assumed to be a circuit for which we want to
  force the output to be one.  This is encoding of SAT.

  For sequential circuits the model checking problem for simple safety
  properties is encoded in the same way.

Proposal for Future Extensions
  
  The most important extension of the format is to include word level
  operators, which would also allow to capture even hierarchical RTL models
  and more general constraints.  One simple way to achieve this is to add new
  operators through an escape mechanism.
  
  The current proposal simply allows more general gates.  These definitions
  are placed where ANDs are usually defined.  To start the definition of a
  more general operator  use the literal '0' as escape sequence in the ASCII
  format and the zero byte in the binary format.  The escape sequence is
  followed by a non negative number which denotes the type of the operator
  and its arguments.  The arguments are partitioned into three sequences,
  the parameters, inputs and outputs.  Each list starts with the number of
  elements.

  The parameters are simply unsigned numbers and should not contain
  literals.  The inputs are signed literals, the outputs define new
  literals.

  We suggest to have the following predefined types:
    
  type  operator               arguments

    0   quantifier             1 omega 2 lit body 1 out

                               omega=1->universal, omega=0->existential

    1   generic circuit        k p1..pk n i1..in m o1..om

    2   adder                  0 2*n+1 cin x1..xn n+1 y1..yn s1..sn cout

    3   cmp                    1 p 2*n x1..xn y1..yn 1 o
                               p=0->op=le, p=1->op=lt, p=2->op=ge, p=3->op=gt

    4   mux                    1 n
                               n+2*n*w (n-bit selector, 2^n w-bit words input)
                               w (one w-bit output)

                               selector word starts with LSB
                               1st word is selected by the all zero selector

    5   cardinality constraint 2 p k n x1 ... xn
                               p=0->op=le, p=1->op=lt, p=2->op=ge, p=3->op=gt

                               x1+..+xn op k

    6   all different          1 w n*w (n w-bit words) 1 o
        constraint
 
  More arithmetic operators will be necessary and the actual type encoding
  numbers may change as well.  Please note that these future extensions are
  just a proposal and currently not supported at all.  However, comments
  are very much welcome.
