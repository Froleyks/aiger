         The AIGER And-Inverter Graph (AIG) Format Version 20060915
         ----------------------------------------------------------
              Armin Biere, Johannes Kepler University, 2006

  This report describes the AIG file format as used by the AIGER library.
  The purpose of this report is not only to motivate and document the
  format, but also to allow independent implementations of writers and
  readers by giving precise and unambiguous definitions.

Acknowledgements

  The format went through various incarnations even before real code became
  available.  In particular the following colleagues gave invaluable
  feedback on earlier drafts.

      Robert Brummayer, Alessandro Cimatti, Koen Claessen, Niklas Een,
      Marc Herbstritt, Toni Jussila,Ken McMillan, Fabio Somenzi, Niklas
      Soerenson, Allen Van Gelder.

  We also want to thank Holger Hermanns who started the discussion on having
  a model checking competition affiliated to CAV and also provided strong
  support after the idea became more concrete.

Introduction

  The name AIGER contains as one part the acronym AIG of And-Inverter
  Graphs and also if pronounced in German sounds like the name of the
  'Eiger', a mountain in the Swiss alps.  This choice should emphasize the
  origin of this format. It was first openly discussed at the Alpine
  Verification Meeting 2006 in Ascona as a way to provide a simple, compact
  file format for a model checking competition affiliated to CAV 2007.

  The AIGER format has an ASCII and a binary version.  The ASCII version is
  the format of choice if an AIG is to be saved by an application which
  does not want to use the AIGER library.  It is simple to generate and has
  less restrictions.  The binary format is more restricted and much more
  compact.  It is easier to read and thus should be the format of choice for
  competitions.  The AIGER library comes with conversion utilities of course.

  Let us start with some simple examples in ASCII format which all can be
  found in the 'examples' subdirectory.  An AIGER file in ASCII format
  starts with the format identifier string 'aig' and 5 non negative
  integers 'M', 'I', 'L', 'O', 'A' seperated by spaces.

  The intepretation of the integers is as follows

    M = maximum variable index
    I = number of inputs
    L = number of latches
    O = number of outputs
    A = number of AND gates

  The empty circuit without inputs nor outputs consists of the single line

    aig 0 0 0 0 0               header
  
  The file that consists of the following two lines

    aig 0 0 0 1 0               header
    0                           output

  represents the constant FALSE.  Note that the comments to the right are
  not part of the file.  The following file represents the constant TRUE:
    
    aig 0 0 0 1 0
    1

  The single '1' in the header specifies that the number of outputs is one.
  In this case the header is followed by a line which contains the literal
  of the single output.

  The following file is a buffer

    aig 1 1 0 1 0               header
    2                           input
    2                           output

  and the following an inverter

    aig 1 1 0 1 0               header
    2                           input
    3                           output          !1

  The maximal variable index is 1, the first number.  The second number
  represents the number of inputs.  The first line consists of the single
  input literal.  A variable is transformed into a literal by multiplying
  it by two.  In the first case the output specified on the last line leaves
  the input unchanged.  In the second case the output inverts the input.  The
  output literal '3' has its sign bit, the least significant bit, set to one
  accordingly.
  
  An AND gate looks as follows

    aig 3 2 0 1 1
    2                           input 0
    4                           input 1
    6                           output 0
    6 2 4                       AND gate 0      1 & 2

  The literal representing the AND gate is '6' with variable index '3',
  the first number in the header, which denotes the maximal variable index.
  The last number is the number of AND gates.

  An OR gate can be formulated as

    aig 3 2 0 1 1
    2                           input 0
    4                           input 1
    7                           output 0        !(!1 & !2)
    6 3 5                       AND gate 0      !1 & !2

  Let us now turn to a more complete combinational circuit

    aig 7 2 0 2 3               header line
    2                           input 0         1st addend bit 'x'
    4                           input 1         2nd addend bit 'y'
    6                           output 0        sum bit        's'
    12                          output 1        carry          'c'
    6 13 15                     AND gate 0      x ^ y
    12 2 4                      AND gate 1      x & y
    14 3 5                      AND gate 2      !x & !y
    i0 2 x                      symbol
    i1 4 y                      symbol
    o0 6 s                      symbol
    o1 12 c                     symbol
    c                           comment header
    half adder                  comment

  The symbol table is optional and does not need to be complete, but may
  only contain symbols for inputs, latches, or outputs.

  Sequential circuits have latches as state elements. Here is a toggle flip
  flop, which has no input, one latch, and two outputs, its current state and
  its negation:

    aig 1 0 1 2 0
    2 3                         latch 0 with next state literal
    2                           output 0
    3                           output 1

  Latches are always assumed to be initialized to zero.  The same toggle
  flip flop with an enable and additional explicit active low reset input:

    aig 7 2 1 2 4
    2                           input 0         'enable'
    4                           input 1         'reset'
    6 8                         latch 0         Q next(Q)
    6                           output 0        Q
    7                           output 1        !Q
    8 4 10                      AND gate 0      reset & (enable ^ Q)
    10 13 15                    AND gate 1      enable ^ Q
    12 2 6                      AND gate 2      enable & Q
    14 3 7                      AND gate 3      !enable & !Q

  The order of the literals and the definitions of the AND gates
  is irrelevant.  The binary format described more formally below places
  more restrictions on the order and also does not allow unused literals.

Design Choices
  
  The format should allow to model combinational circuits.

  Structural SAT problems can be described.
  
  The format should allow to model sequential circuits.

  Model checking problems can be described.

  The operators are restricted to bit level.

  The set of operators needs to be as simple as possible.

  A compact standardized binary format should be available.

  The ASCII format should be as easy as possible to write by programs.

  The binary format should be as easy as possible to read by programs.

  A symbol table and comments can be included.

  Symbol table and comments can be ignored reading the file sequentially.

  Some simple form of extensibility should be possible.

Header

  The AIGER format describes circuits by multi-rooted And-Inverter Graphs
  (AIGs).  A file in AIGER format has to start with format identifier
  string, which is either 'aig' for ASCII format or 'big for the binary
  format.  After the format identifier string and one space character
  follow 5 non negative integers 'M', 'I', 'L', 'O', and 'A' in ASCII
  encoding.  The maximal variable index 'M' is the first number in the
  header.  The circuit has 'I' inputs, 'L' latches, 'O' outputs, and
  consists of 'A' AND gates.  If all variables are used and there are no
  unused AND gates then 'M = I + L + A'.

  An unsigned respectively non negative integer is either '0' or a strictly
  positive ASCII encoded digit followed by a sequence of arbitray digits
  including '0'.  The 'a' or 'b' of the format identifier string is the
  first character of the file.  The format identifier string 'aig' and the
  numbers are all separated by exactly one space character ' '.  The header
  line ends with a new line character immediately after the last digit of
  the number of ands 'A'.

Variables and Literals

  Literals are constants or signed variables and are also represented by
  unsigned integers.  The least significant bit of the unsigned word
  encoding a literal is the sign bit.  The remaining bits represent the
  variable index.
  
  In essence, to obtain the sign bit of a literal we take its unsigned
  integer representation modulo 2.  A sign bit of one means negated, a sign
  bit of zero unnegated.  To extract the variable from a literal we divide
  it by 2.  To obtain a literal from a variable in the other direction we
  multiple the variable index by 2 and optionally add 1 if the variable
  should be negated.   A literal can be negated by just toggling its least
  significant bit.
  
  The constant FALSE is represented by the literal '0', the constant TRUE by
  '1'.  This implies, that FALSE is unnegated, while TRUE is negated.

  AIGER only models cycle-accurate models.  Latches are assumed to have a
  reset zero state, e.g. are initialized to zero and no explicit reset nor
  clock signal is necessary.

ASCII Format
  
  The ASCII format has 'aig' as format identifier in the header, which is an
  acronym for ASCII AIG.  The names of files in the ASCII format are
  supposed to have an '.aig'  extension.  The current AIGER library also
  supports files compressed with GNU GZIP.  In this case an additional '.gz'
  suffix is expected.

  After the header the 'I' inputs are listed, one per line, as unnegated
  literal, e.g.  represented as even positive integers.  Then the 'L'
  latches are defined.  Again one latch per line.  Each line consists of
  exactly two positive integers separated by a space character.  The first
  is even and denotes the current state of the latch. The second is the
  literal that defines the next state function of this latch.  
  
  Then the 'O' output literals are listed, one per line.  Here arbitrary
  literals are allowed.  This concludes the interface part and the
  definitions of the 'A' AND gates follow.

  The definition of an AND gate consists of three positive integers all
  written on one line and separated by exactly one space character.  The
  first integer is even and represents the literal or left-hand side (LHS).
  The two other integers represent the literals of the right-hand side
  (RHS) of the AND gate.

  In order to be well formed, the 'I' inputs, the current state literal of
  the 'L' latches, e.g. the pseudo-primary inputs, and the LHS of the 'A'
  AND gates are all different and define exactly 'I + L + A' literals.  The
  other literals, except for the two constants '0' and '1', are undefined
  and can not be used as output, as next state literal, nor on the RHS of an
  AND.  Furthermore, the definitions of the ANDs have to be acyclic.  To be
  more precise: The literal on the LHS of an AND is defined to depend on the
  literals on the RHS after stripping sign bits.  The transitive non
  reflexive closure of this dependency relation has to be acyclic.

  In the ASCII format both checking for undefined literals and checking for
  cyclic dependencies has to be done explicitly.  This is the price one has
  to pay for a simple, easy to generate and less restricted format.  The
  binary format on the other hand has a strict order requirement on the
  literals not only for inputs and latches, but also for the RHS literals
  with respect to the LHS literals. The binary format does not require such
  an explicit check.

  Also note that the number of defined literals does not have to match the
  maximal variable index 'M'.  In essence, some literals may just not be
  used in ASCII format.

Symbols
  
  After the definitions of the AND gates an optional symbol table may
  follow.  A symbol is an arbitrary ASCII string of printable characters
  excluding the new line character.  Symbols can only be attached to inputs,
  latches and outputs and there is at most one symbol per input, latch or
  output allowed.  A symbol entry makes up one line in the input and
  consists of a symbol type specifier which is either 'I', 'L', or 'O' on
  the first character position, followed by a position, which is not
  separated by a space, and then the literal separated by a space.  After
  another space the symbol name starts and continues until but not including
  the next new line character.  Therefore a symbol table entry looks as
  follows:
    
    [ilo]pos lit
  
  The position 'pos' of the symbol denotes the position of the input, latch,
  or AND gate, in the list of inputs, latches, and ANDs respectively.  It
  has to follow immediately the symbol type idenfier without space.  The
  literal has to be the same as the actual literal given at that position in
  the corresponding list.

  The symbol table is put after all the definitions, such that an
  application reading an AIG can just stop reading the file after it has
  read the definitions.  The same applies to comments which come last.

Comments
 
  After the symbol table an optional comment section may start.  The comment
  section starts with a 'c' character followed by a new line.  The following
  lines are comments.  Each comment starts at the first character of a line
  and extends until the next new line character.  There can be no comment
  lines at all, but the last comment has to be terminated by a new line
  character, which then also has to be the last character of the file.

Binary Format Motivation

  The binary format is more restricted than the ASCII format.  Literals have to
  follow a specific order.  The order restrictions and using a
  two-complement binary representation of numbers makes the binary format
  not only easier to read but also much more compact.  Experiments show that
  these restrictions and an additional delta encoding result in smaller
  uncompressed files.  The binary format is often smaller than the same
  model in GZIP compressed ASCII format.  Without symbol tables the
  reduction is typically a factor of two compared to the GZIP compressed
  ASCII format.  Compressing the binary format results in additional
  reduction.  
  
  As example consider the following SMV model 'texas.parsesys^1.E.smv', the
  largest benchmark from the TIP suite:  
  
    1204637 texas.parsesys^1.E.smv/unmangled.smv
     485595 texas.parsesys^1.E.smv/mangled.smv
     192282 texas.parsesys^1.E.smv/unstripped.aig
     185100 texas.parsesys^1.E.smv/stripped.aig
     114796 texas.parsesys^1.E.smv/unmangled.smv.gz
      97455 texas.parsesys^1.E.smv/mangled.smv.gz
      73282 texas.parsesys^1.E.smv/unstripped.aig.gz
      70698 texas.parsesys^1.E.smv/stripped.aig.gz
      45281 texas.parsesys^1.E.smv/unstripped.big
      38099 texas.parsesys^1.E.smv/stripped.big
      28989 texas.parsesys^1.E.smv/unstripped.big.gz
      26257 texas.parsesys^1.E.smv/stripped.big.gz

  After flattening and binary encoding, the SMV model has a size of 1204637
  bytes (unmangled.smv).  Simply renaming the symbols, e.g. mangling them,
  results in a reduction in file size of almost a factor of 3.  At least
  another factor of two can be obtained by translating the original
  unmangled SMV file into an AIG and writing it in the ASCII format
  (unstripped.aig) with our tool 'smvtoaig'.  This file still contains all
  the unmangled symbols.  Stripping the symbol table reduces the size
  slightly (stripped.aig).  Compressing these four files with GZIP results
  in another reduction of at least 2.  In particular note, that the
  uncompressed and unstripped binary format is two third the size of the
  compressed and stripped ASCII format.  Finally using the binary format,
  gives almost an additional factor of two.  Compressing the binary format
  gives further reduction.

  For the whole TIP suite the sizes are as follows

    11300354 tip/unmangled.tar.gz
     7957504 tip/mangled.tar.gz
     2663375 tip/aigtosmv.tar.gz
     2294823 tip/aig.tar.gz
      349036 tip/big.tar.gz

  Here we stripped the symbols in the AIG case.  The tar file
  'aigtosmv.tar.gz' contains the result of translating the files from binary
  format (tip/big.tar.gz) back into SMV format.  It is also remarkable, that
  with the exception of the binary format, GZIP can not make use of the fact
  that most of the models in the TIP suite occur multiple times though with
  different properties.

  Finally, as a combinational example consider the CNF benchmark 'f10bidw'
  submitted by P. Manolios and S.K. Srinivasanused to the SAT Race 2006 with
  800k variables and roughly 2.4 million clauses.  Since the original
  benchmark consists of only AND gates and one unit clause, we could easily
  extract a corresponding AIG with our tool 'cnf2aig'.


    55125988 f10bidw.cnf
    17811297 f10bidw.aig
    11743634 f10bidw.cnf.gz
     5864057 f10bidw.aig.gz
     2979121 f10bidw.big
     1967817 f10bidw.big.gz

  These experiments show that using a binary format can considerably reduce
  space requirements for storing benchmarks.  Furthermore it will reduce
  reading time for these benchmarks.  This reduction is even more important
  if the AIGER format is used for large combinational benchmarks, e.g. in a
  SAT context as in the last example.
  
Binary Format Definition

  The binary format is semantically a subset of the ASCII format with a
  slightly different syntax.  The binary format may need to reencode
  literals, but translating a file in binary format into ASCII format and
  then back in to binary format will result in the same file.

  The header of an AIGER file in binary format has 'big' as format
  identifier, but otherwise is identical to the ASCII header.  The standard
  file extension for the binary format is therefore 'big' It reminds the
  user that it is supposed to be used for large AIGs.  At the same time it
  is an acronym for binary AIG format.  
  
  An header for the binary format is still in ASCII encoding and looks as
  follows:

    big M I L O A

  Constants, variables and literals are handled in the same way as in the
  ASCII format.  The first simplifying restriction is, that the input
  literals come first, followed by the pseudo-primary inputs of the latches
  and then all LHS literals of AND gates.  These literals form consecutive
  intervals of even positive integers without gaps from '2' to '2 * M'.

      inputs            2,          4,  ... ,  2*I
      latches       2*I+2,      2*I+4,  ... ,  2*(I+L)
      ands      2*(I+L)+2,  2*(I+L)+4,  ... ,  2*(I+L+A)

  All literals have to be defined, and therefore 'M = I + L + A'.  With this
  restriction it becomes possible that the inputs and the current state
  literals of the latches do not have to be explicitly listed.

  After the header the list of 'L' next state literals follows, one per
  latch on a single line.  Then the 'O' outputs are listed, one per line.

  In the binary format we assume that the AND gates are ordered and respect
  the child parent relation.  AND gates with smaller literals on the LHS
  come first.  Therefore we can assume that the literals on the right-hand
  side of a definition of an AND gate are smaller than the LHS literal.
  Furthermore we can sort the literals on the RHS, such that the larger
  literal comes first.  A definition thus consists of three literals
    
      lhs rhs0 rhs1

  with 'lhs' even and 'lhs > rhs0 > rhs1'.  Also the variable indices are
  pairwise different to avoid combinational self loops.  Since the LHS
  indices of the definitions are all consecutive (as even integers),
  the binary format does not have to keep 'lhs'.  In addition, we can use
  the order restriction and only write the differences 'delta0' and 'delta1'
  instead of 'rhs0' and 'rhs1', with

      delta0 = lhs - rhs0,  delta1 = rhs0 - rhs1
  
  The differences will all be strictly positive, and in practice often very
  small.  We can take advantage of this fact by the simple little-endian
  encoding of unsigned integers of the next section.  After the binary delta
  encoding of the RHSs of all AND gates, the optional symbol table and
  optional comment section start with the same format as in the ASCII case.

Binary Encoding of Deltas
  
  Assume that 'wi, ..., w0' are 7-bit words, 'w1' to 'wi' all non zero and
  the unsigned number 'x' can be represented as
    
    x = w0 + 2^7*w1 + 2^14*w2 + 2^(7*i)*wi

  The binary encoding of x in AIGER is the sequence of i bytes b0, ... bi:

    1w0, 1w1, 1w2, ..., 0wi

  The MSB of a byte in this sequence signals whether this byte is the last
  byte in the sequence, or whether there are still more bytes to follow.
  Here are some examples:
    
      unsigned integer   byte sequence of encoding (in hexadecimal)
 
                     x   b0 b1 b2 b3
                        
                     0   00
                     1   01
      2^7-1    =   127   7f
      2^7      =   128   80 01
      2^8  + 2 =   258   82 02
      2^14 - 1 = 16383   ff 7f
      2^14 + 3 = 16387   83 80 01
      2^28 - 1           ff ff ff 7f
      2^28 + 7           87 80 80 80 01

  This encoding can reduce the number of bytes by at most a factor of 4,
  which very often in practice is almost reached, in particular in our
  application where many small numbers are expected.
  
  This binary encoding of arbitrary precision unsigned integers is
  platform-independent and thus 64-bit clean.  Unfortunately, this is not
  true for the following code snippets in C.  We also just ignore overflows
  and file errors, but otherwise this code shows that encoding and decoding
  is very simple.

    unsigned
    decode (FILE * file)
    {
      unsigned x = 0, i = 0;
      unsigned char ch;

      while ((ch = getc (file)) & 0x80)
        x |= (ch & 0x7f) << (7 * i++);

      return x | (ch << (7 * i));
    }

    void
    encode (FILE * file, unsigned x)
    {
      unsigned char ch;

      while (x & ~0x7f)
        {
          ch = (x & 0x7f) | 0x80;
          putc (ch, file);
          x >>= 7;
        }
     
      ch = x;
      putc (ch, file);
    }

  Note that the decoder above is not robust at all, since an early EOF may
  actually result in an infinite loop.  In the binary format of AIGER we
  always expect a complete sequence.  Therefore if an EOF is read before
  the sequence is complete a parse error occurs.  A simple solution to this
  problem is to check the return value of 'getc'.  If the value is EOF then
  abort decoding with a parse error.

Property Checking
  
  The AIGER format can easily be used for various types of property
  checking.  A combinational circuits with no latches, e.g. L = 0, and
  exactly one output can be assumed to be a circuit for which we want to
  force the output to be one.  This is encoding of SAT.

  For sequential circuits the model checking problem for simple safety
  properties is encoded in the same way.

Proposal for Future Extensions
  
  The most important extension of the format is to include word level
  operators, which would also allow to capture even hierarchical RTL models
  and more general constraints.  One simple way to achieve this is to add new
  operators through an escape mechanism.
  
  The current proposal simply allows more general gates.  These definitions
  are placed where ANDs are usually defined.  To start the definition of a
  more general operator  use the literal '0' as escape sequence in the ASCII
  format and the zero byte in the binary format.  The escape sequence is
  followed by a non negative number which denotes the type of the operator
  and its arguments.  The arguments are partitioned into three sequences,
  the parameters, inputs and outputs.  Each list starts with the number of
  elements.

  The parameters are simply unsigned numbers and should not contain
  literals.  The inputs are signed literals, the outputs define new
  literals.

  We suggest to have the following predefined types:
    
  type  operator               arguments

    0   quantifier             1 omega 2 lit body 1 out

                               omega=1->universal, omega=0->existential

    1   generic circuit        k p1..pk n i1..in m o1..om

    2   adder                  0 2*n+1 cin x1..xn n+1 y1..yn s1..sn cout

    3   cmp                    1 p 2*n x1..xn y1..yn 1 o
                               p=0->op=le, p=1->op=lt, p=2->op=ge, p=3->op=gt

    4   mux                    1 n
                               n+2*n*w (n-bit selector, 2^n w-bit words input)
                               w (one w-bit output)

                               selector word starts with LSB
                               1st word is selected by the all zero selector

    5   cardinality constraint 2 p k n x1 ... xn
                               p=0->op=le, p=1->op=lt, p=2->op=ge, p=3->op=gt

                               x1+..+xn op k

    6   all different          1 w n*w (n w-bit words) 1 o
        constraint
 
  More arithmetic operators will be necessary and the actual type encoding
  numbers may change as well.  Please note that these future extensions are
  just a proposal and currently not supported at all.  However, comments
  are very much welcome.
